<?php
/**
 * ScheduleApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Redback API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 * Contact: ITOps@redbacktech.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.64
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ScheduleApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ScheduleApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation scheduleCancelSchedule
     *
     * Deletes a schedule
     *
     * @param  string $site_id The site (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfBoolean
     */
    public function scheduleCancelSchedule($site_id, $schedule_id)
    {
        list($response) = $this->scheduleCancelScheduleWithHttpInfo($site_id, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleCancelScheduleWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $site_id The site (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfBoolean, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCancelScheduleWithHttpInfo($site_id, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleRequest($site_id, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfBoolean',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCancelScheduleAsync
     *
     * Deletes a schedule
     *
     * @param  string $site_id The site (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleAsync($site_id, $schedule_id)
    {
        return $this->scheduleCancelScheduleAsyncWithHttpInfo($site_id, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCancelScheduleAsyncWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $site_id The site (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleAsyncWithHttpInfo($site_id, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleRequest($site_id, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCancelSchedule'
     *
     * @param  string $site_id The site (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCancelScheduleRequest($site_id, $schedule_id)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling scheduleCancelSchedule'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleCancelSchedule'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Site/{siteId}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($site_id !== null) {
            $resourcePath = str_replace(
                '{' . 'siteId' . '}',
                ObjectSerializer::toPathValue($site_id),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleCancelScheduleByNmi
     *
     * Deletes a schedule
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfBoolean
     */
    public function scheduleCancelScheduleByNmi($nmi, $schedule_id)
    {
        list($response) = $this->scheduleCancelScheduleByNmiWithHttpInfo($nmi, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleCancelScheduleByNmiWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfBoolean, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCancelScheduleByNmiWithHttpInfo($nmi, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleByNmiRequest($nmi, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfBoolean',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCancelScheduleByNmiAsync
     *
     * Deletes a schedule
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleByNmiAsync($nmi, $schedule_id)
    {
        return $this->scheduleCancelScheduleByNmiAsyncWithHttpInfo($nmi, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCancelScheduleByNmiAsyncWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleByNmiAsyncWithHttpInfo($nmi, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleByNmiRequest($nmi, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCancelScheduleByNmi'
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCancelScheduleByNmiRequest($nmi, $schedule_id)
    {
        // verify the required parameter 'nmi' is set
        if ($nmi === null || (is_array($nmi) && count($nmi) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nmi when calling scheduleCancelScheduleByNmi'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleCancelScheduleByNmi'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Nmi/{nmi}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($nmi !== null) {
            $resourcePath = str_replace(
                '{' . 'nmi' . '}',
                ObjectSerializer::toPathValue($nmi),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleCancelScheduleForSerialNumber
     *
     * Deletes a schedule
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfBoolean
     */
    public function scheduleCancelScheduleForSerialNumber($serial_number, $schedule_id)
    {
        list($response) = $this->scheduleCancelScheduleForSerialNumberWithHttpInfo($serial_number, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleCancelScheduleForSerialNumberWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfBoolean, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCancelScheduleForSerialNumberWithHttpInfo($serial_number, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleForSerialNumberRequest($serial_number, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfBoolean',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCancelScheduleForSerialNumberAsync
     *
     * Deletes a schedule
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleForSerialNumberAsync($serial_number, $schedule_id)
    {
        return $this->scheduleCancelScheduleForSerialNumberAsyncWithHttpInfo($serial_number, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCancelScheduleForSerialNumberAsyncWithHttpInfo
     *
     * Deletes a schedule
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCancelScheduleForSerialNumberAsyncWithHttpInfo($serial_number, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfBoolean';
        $request = $this->scheduleCancelScheduleForSerialNumberRequest($serial_number, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCancelScheduleForSerialNumber'
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCancelScheduleForSerialNumberRequest($serial_number, $schedule_id)
    {
        // verify the required parameter 'serial_number' is set
        if ($serial_number === null || (is_array($serial_number) && count($serial_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial_number when calling scheduleCancelScheduleForSerialNumber'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleCancelScheduleForSerialNumber'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/SerialNumber/{serialNumber}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial_number !== null) {
            $resourcePath = str_replace(
                '{' . 'serialNumber' . '}',
                ObjectSerializer::toPathValue($serial_number),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleCreateSchedule
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDto $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto
     */
    public function scheduleCreateSchedule($body)
    {
        list($response) = $this->scheduleCreateScheduleWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation scheduleCreateScheduleWithHttpInfo
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDto $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCreateScheduleWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCreateScheduleAsync
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleAsync($body)
    {
        return $this->scheduleCreateScheduleAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCreateScheduleAsyncWithHttpInfo
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCreateSchedule'
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCreateScheduleRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling scheduleCreateSchedule'
            );
        }

        $resourcePath = '/Api/v2/Schedule/Create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleCreateScheduleByNmi
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDtoByNmi $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto
     */
    public function scheduleCreateScheduleByNmi($body)
    {
        list($response) = $this->scheduleCreateScheduleByNmiWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation scheduleCreateScheduleByNmiWithHttpInfo
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDtoByNmi $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCreateScheduleByNmiWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleByNmiRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCreateScheduleByNmiAsync
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDtoByNmi $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleByNmiAsync($body)
    {
        return $this->scheduleCreateScheduleByNmiAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCreateScheduleByNmiAsyncWithHttpInfo
     *
     * Creates a new schedule for a site
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDtoByNmi $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleByNmiAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleByNmiRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCreateScheduleByNmi'
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestDtoByNmi $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCreateScheduleByNmiRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling scheduleCreateScheduleByNmi'
            );
        }

        $resourcePath = '/Api/v2/Schedule/Create/By/Nmi';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleCreateScheduleBySerialNumber
     *
     * Creates a new schedule for a serial number
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestBySerialNumberDto $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto
     */
    public function scheduleCreateScheduleBySerialNumber($body)
    {
        list($response) = $this->scheduleCreateScheduleBySerialNumberWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation scheduleCreateScheduleBySerialNumberWithHttpInfo
     *
     * Creates a new schedule for a serial number
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestBySerialNumberDto $body Request data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleCreateScheduleBySerialNumberWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleBySerialNumberRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleCreateScheduleBySerialNumberAsync
     *
     * Creates a new schedule for a serial number
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestBySerialNumberDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleBySerialNumberAsync($body)
    {
        return $this->scheduleCreateScheduleBySerialNumberAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleCreateScheduleBySerialNumberAsyncWithHttpInfo
     *
     * Creates a new schedule for a serial number
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestBySerialNumberDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleCreateScheduleBySerialNumberAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfCreateScheduleResponseDto';
        $request = $this->scheduleCreateScheduleBySerialNumberRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleCreateScheduleBySerialNumber'
     *
     * @param  \Swagger\Client\Model\CreateScheduleRequestBySerialNumberDto $body Request data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleCreateScheduleBySerialNumberRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling scheduleCreateScheduleBySerialNumber'
            );
        }

        $resourcePath = '/Api/v2/Schedule/Create/By/SerialNumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSchedulesByNmi
     *
     * Lists all schedules for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfListSchedulesResponseWithNmiDto
     */
    public function scheduleGetSchedulesByNmi($nmi, $include_stale = null)
    {
        list($response) = $this->scheduleGetSchedulesByNmiWithHttpInfo($nmi, $include_stale);
        return $response;
    }

    /**
     * Operation scheduleGetSchedulesByNmiWithHttpInfo
     *
     * Lists all schedules for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfListSchedulesResponseWithNmiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSchedulesByNmiWithHttpInfo($nmi, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseWithNmiDto';
        $request = $this->scheduleGetSchedulesByNmiRequest($nmi, $include_stale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseWithNmiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSchedulesByNmiAsync
     *
     * Lists all schedules for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesByNmiAsync($nmi, $include_stale = null)
    {
        return $this->scheduleGetSchedulesByNmiAsyncWithHttpInfo($nmi, $include_stale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSchedulesByNmiAsyncWithHttpInfo
     *
     * Lists all schedules for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesByNmiAsyncWithHttpInfo($nmi, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseWithNmiDto';
        $request = $this->scheduleGetSchedulesByNmiRequest($nmi, $include_stale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSchedulesByNmi'
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSchedulesByNmiRequest($nmi, $include_stale = null)
    {
        // verify the required parameter 'nmi' is set
        if ($nmi === null || (is_array($nmi) && count($nmi) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nmi when calling scheduleGetSchedulesByNmi'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Nmi/{nmi}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_stale !== null) {
            $queryParams['includeStale'] = ObjectSerializer::toQueryValue($include_stale, null);
        }

        // path params
        if ($nmi !== null) {
            $resourcePath = str_replace(
                '{' . 'nmi' . '}',
                ObjectSerializer::toPathValue($nmi),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSchedulesBySerialNumber
     *
     * Lists all schedules for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfSchedulesBySerialNumberDto
     */
    public function scheduleGetSchedulesBySerialNumber($serial_number, $include_stale = null)
    {
        list($response) = $this->scheduleGetSchedulesBySerialNumberWithHttpInfo($serial_number, $include_stale);
        return $response;
    }

    /**
     * Operation scheduleGetSchedulesBySerialNumberWithHttpInfo
     *
     * Lists all schedules for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfSchedulesBySerialNumberDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSchedulesBySerialNumberWithHttpInfo($serial_number, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfSchedulesBySerialNumberDto';
        $request = $this->scheduleGetSchedulesBySerialNumberRequest($serial_number, $include_stale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfSchedulesBySerialNumberDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSchedulesBySerialNumberAsync
     *
     * Lists all schedules for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesBySerialNumberAsync($serial_number, $include_stale = null)
    {
        return $this->scheduleGetSchedulesBySerialNumberAsyncWithHttpInfo($serial_number, $include_stale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSchedulesBySerialNumberAsyncWithHttpInfo
     *
     * Lists all schedules for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesBySerialNumberAsyncWithHttpInfo($serial_number, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfSchedulesBySerialNumberDto';
        $request = $this->scheduleGetSchedulesBySerialNumberRequest($serial_number, $include_stale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSchedulesBySerialNumber'
     *
     * @param  string $serial_number Serial number (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSchedulesBySerialNumberRequest($serial_number, $include_stale = null)
    {
        // verify the required parameter 'serial_number' is set
        if ($serial_number === null || (is_array($serial_number) && count($serial_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial_number when calling scheduleGetSchedulesBySerialNumber'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/SerialNumber/{serialNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_stale !== null) {
            $queryParams['includeStale'] = ObjectSerializer::toQueryValue($include_stale, null);
        }

        // path params
        if ($serial_number !== null) {
            $resourcePath = str_replace(
                '{' . 'serialNumber' . '}',
                ObjectSerializer::toPathValue($serial_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSchedulesBySite
     *
     * Lists all schedules for a site
     *
     * @param  string $site_id The site (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfListSchedulesResponseDto
     */
    public function scheduleGetSchedulesBySite($site_id, $include_stale = null)
    {
        list($response) = $this->scheduleGetSchedulesBySiteWithHttpInfo($site_id, $include_stale);
        return $response;
    }

    /**
     * Operation scheduleGetSchedulesBySiteWithHttpInfo
     *
     * Lists all schedules for a site
     *
     * @param  string $site_id The site (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfListSchedulesResponseDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSchedulesBySiteWithHttpInfo($site_id, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseDto';
        $request = $this->scheduleGetSchedulesBySiteRequest($site_id, $include_stale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSchedulesBySiteAsync
     *
     * Lists all schedules for a site
     *
     * @param  string $site_id The site (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesBySiteAsync($site_id, $include_stale = null)
    {
        return $this->scheduleGetSchedulesBySiteAsyncWithHttpInfo($site_id, $include_stale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSchedulesBySiteAsyncWithHttpInfo
     *
     * Lists all schedules for a site
     *
     * @param  string $site_id The site (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSchedulesBySiteAsyncWithHttpInfo($site_id, $include_stale = null)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfListSchedulesResponseDto';
        $request = $this->scheduleGetSchedulesBySiteRequest($site_id, $include_stale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSchedulesBySite'
     *
     * @param  string $site_id The site (required)
     * @param  bool $include_stale If true then schedules in the past are returned. Please note that stale schedules are automatically removed without notice and even with this flag set the returned set is not a full recod of past schedules. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSchedulesBySiteRequest($site_id, $include_stale = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling scheduleGetSchedulesBySite'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Site/{siteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_stale !== null) {
            $queryParams['includeStale'] = ObjectSerializer::toQueryValue($include_stale, null);
        }

        // path params
        if ($site_id !== null) {
            $resourcePath = str_replace(
                '{' . 'siteId' . '}',
                ObjectSerializer::toPathValue($site_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSingleScheduleInfo
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $site_id Id of the site (required)
     * @param  string $schedule_id The scedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfScheduleDto
     */
    public function scheduleGetSingleScheduleInfo($site_id, $schedule_id)
    {
        list($response) = $this->scheduleGetSingleScheduleInfoWithHttpInfo($site_id, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleGetSingleScheduleInfoWithHttpInfo
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $site_id Id of the site (required)
     * @param  string $schedule_id The scedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfScheduleDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSingleScheduleInfoWithHttpInfo($site_id, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleDto';
        $request = $this->scheduleGetSingleScheduleInfoRequest($site_id, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfScheduleDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSingleScheduleInfoAsync
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $site_id Id of the site (required)
     * @param  string $schedule_id The scedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoAsync($site_id, $schedule_id)
    {
        return $this->scheduleGetSingleScheduleInfoAsyncWithHttpInfo($site_id, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSingleScheduleInfoAsyncWithHttpInfo
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $site_id Id of the site (required)
     * @param  string $schedule_id The scedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoAsyncWithHttpInfo($site_id, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleDto';
        $request = $this->scheduleGetSingleScheduleInfoRequest($site_id, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSingleScheduleInfo'
     *
     * @param  string $site_id Id of the site (required)
     * @param  string $schedule_id The scedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSingleScheduleInfoRequest($site_id, $schedule_id)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling scheduleGetSingleScheduleInfo'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleGetSingleScheduleInfo'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Site/{siteId}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($site_id !== null) {
            $resourcePath = str_replace(
                '{' . 'siteId' . '}',
                ObjectSerializer::toPathValue($site_id),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSingleScheduleInfoByNmi
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfScheduleWithNmiDto
     */
    public function scheduleGetSingleScheduleInfoByNmi($nmi, $schedule_id)
    {
        list($response) = $this->scheduleGetSingleScheduleInfoByNmiWithHttpInfo($nmi, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleGetSingleScheduleInfoByNmiWithHttpInfo
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfScheduleWithNmiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSingleScheduleInfoByNmiWithHttpInfo($nmi, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleWithNmiDto';
        $request = $this->scheduleGetSingleScheduleInfoByNmiRequest($nmi, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfScheduleWithNmiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSingleScheduleInfoByNmiAsync
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoByNmiAsync($nmi, $schedule_id)
    {
        return $this->scheduleGetSingleScheduleInfoByNmiAsyncWithHttpInfo($nmi, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSingleScheduleInfoByNmiAsyncWithHttpInfo
     *
     * Gets information about a specific schedule for a site
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoByNmiAsyncWithHttpInfo($nmi, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleWithNmiDto';
        $request = $this->scheduleGetSingleScheduleInfoByNmiRequest($nmi, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSingleScheduleInfoByNmi'
     *
     * @param  string $nmi National Metering Identifier (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSingleScheduleInfoByNmiRequest($nmi, $schedule_id)
    {
        // verify the required parameter 'nmi' is set
        if ($nmi === null || (is_array($nmi) && count($nmi) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nmi when calling scheduleGetSingleScheduleInfoByNmi'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleGetSingleScheduleInfoByNmi'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/Nmi/{nmi}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($nmi !== null) {
            $resourcePath = str_replace(
                '{' . 'nmi' . '}',
                ObjectSerializer::toPathValue($nmi),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleGetSingleScheduleInfoBySerialNumber
     *
     * Gets information about a specific schedule for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultSingleOfScheduleSnDto
     */
    public function scheduleGetSingleScheduleInfoBySerialNumber($serial_number, $schedule_id)
    {
        list($response) = $this->scheduleGetSingleScheduleInfoBySerialNumberWithHttpInfo($serial_number, $schedule_id);
        return $response;
    }

    /**
     * Operation scheduleGetSingleScheduleInfoBySerialNumberWithHttpInfo
     *
     * Gets information about a specific schedule for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultSingleOfScheduleSnDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleGetSingleScheduleInfoBySerialNumberWithHttpInfo($serial_number, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleSnDto';
        $request = $this->scheduleGetSingleScheduleInfoBySerialNumberRequest($serial_number, $schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultSingleOfScheduleSnDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scheduleGetSingleScheduleInfoBySerialNumberAsync
     *
     * Gets information about a specific schedule for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoBySerialNumberAsync($serial_number, $schedule_id)
    {
        return $this->scheduleGetSingleScheduleInfoBySerialNumberAsyncWithHttpInfo($serial_number, $schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleGetSingleScheduleInfoBySerialNumberAsyncWithHttpInfo
     *
     * Gets information about a specific schedule for an inverter
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleGetSingleScheduleInfoBySerialNumberAsyncWithHttpInfo($serial_number, $schedule_id)
    {
        $returnType = '\Swagger\Client\Model\ResultSingleOfScheduleSnDto';
        $request = $this->scheduleGetSingleScheduleInfoBySerialNumberRequest($serial_number, $schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleGetSingleScheduleInfoBySerialNumber'
     *
     * @param  string $serial_number Serial number (required)
     * @param  string $schedule_id The schedule (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scheduleGetSingleScheduleInfoBySerialNumberRequest($serial_number, $schedule_id)
    {
        // verify the required parameter 'serial_number' is set
        if ($serial_number === null || (is_array($serial_number) && count($serial_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial_number when calling scheduleGetSingleScheduleInfoBySerialNumber'
            );
        }
        // verify the required parameter 'schedule_id' is set
        if ($schedule_id === null || (is_array($schedule_id) && count($schedule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schedule_id when calling scheduleGetSingleScheduleInfoBySerialNumber'
            );
        }

        $resourcePath = '/Api/v2/Schedule/By/SerialNumber/{serialNumber}/{scheduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial_number !== null) {
            $resourcePath = str_replace(
                '{' . 'serialNumber' . '}',
                ObjectSerializer::toPathValue($serial_number),
                $resourcePath
            );
        }
        // path params
        if ($schedule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduleId' . '}',
                ObjectSerializer::toPathValue($schedule_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
